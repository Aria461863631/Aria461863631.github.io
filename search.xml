<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[CLRS-ch34] NP-Completeness]]></title>
    <url>%2F2017%2F12%2F24%2FCLRS%2F34-np%2F</url>
    <content type="text"><![CDATA[CLRS-ch34 NP-Completeness Intro class P solvable in polynomial time class NP problems are verifiable in polynomial time class NPC it is in NP and is as hard as any problem in NP decision problems reductions the first NP-complete problem 34.1 Polynomial time Abstract Problems a binary relation on a set I of instances and a set S of solutions Encodings In order to solve abstract problems, represent problem instances in a way program understands a mapping e from S to the set of binary strings Abstract Proâ€“&gt; Encode --&gt; Concrete Pro --&gt;Algorithm Solve polynomial related Polynomial time solvable exist an algorithm to solve a concrete problem in O(nk)O(n^k)O(nâ€‹kâ€‹â€‹) extend the definition from concrete to abstract by using encoding as bridge A formal language framework alphabet $\Sigma $ a finite set of symbols { 0,1 } language L over Î£ is any set of strings made up of symbols from Î£ { 10, 11, 101 â€¦ } $ \Sigma ^* $ the language of all strings over Î£ view instances for any decision problems Q as a language L over Î£ = { 0 ,1 } Accepted The language L accepted by an algorithm A $ L = { x \in {0,1}^* : A(x) = 1 }$ Reject : A(x) = 0 may runs forever if doesnâ€™t accept Decided The language L decided by an algorithm A if every binary string in L is accepted by A (output 1) and every binary string not in L is rejected ( output 0) $ x \in L $ --&gt; A(x) = 1, $ x\notin L $ --&gt; A(x) = 0 Complexity class P $ P = { L \subseteq { 0, 1}^*$: exists an algorithm A that decides L in polynomial time }\}} 34.2 Polynomial-time verification algorithms verify membership from a certificate in languages Verified The language L verified by an algorithm A $ L = { x \in { 0, 1 }^* ðŸ˜’ there exist $ y \in { 0,1 }^* $ such that A( x,y ) = 1 }\}} Complexity class NP $ NP = { L \subseteq { 0, 1 }^* ðŸ˜’ L={xâˆˆ{0,1}âˆ—:L = \{ x \in \{ 0,1\}^* :L={xâˆˆ{0,1}â€‹âˆ—â€‹â€‹: there exists a certificate y with |y| = $O(|x|^c) $ such that A(x,y) = 1 }}\}\}}} $P \subseteq NP $ Complexity class co-NP set of languages L such that $\bar L \in NP $ Four possibilities for relationship among complexity class 34.3 NP-completeness and reducibility Reducibility if Q â€“ &gt; reduce --&gt; Qâ€™ , Q is â€œno harder to solveâ€ than Qâ€™ $ Q \le_p Qâ€™ $ ( no more than a polynomial factor harder ) NP-completeness LâˆˆNPL \in NPLâˆˆNP Lâ€²â‰¤pLL&#x27; \le_p LLâ€‹â€²â€‹â€‹â‰¤â€‹pâ€‹â€‹L for every Lâ€²âˆˆNPL&#x27; \in NPLâ€‹â€²â€‹â€‹âˆˆNP. (hardest) Theorem 34.4 If any NP-complete problem is polynomial time solvable, then P = NP If any problem in NP is not polynomial-time solvable, then all NP-complete problems are not polynomial-time solvable. Circuit satisfiability Given a boolean combinational circuit composed of AND, OR, and NOT gates, is it satisfiable? 34.5 belongs to NP 34.6 NP-hard basic idea : represent the computation of A(algorithm verify L) as a sequence of configurations. Each configuration is mapped to the next configuration by a boolean combinational circuit M. The output is a distinguished bit in the working storage. The reduction algorithm F constructs a single combinational circuit that computes all configurations produced by a given initial configuration. 34.5 NP-complete problems]]></content>
      <categories>
        <category>CLRS</category>
      </categories>
      <tags>
        <tag>CLRS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbinä¸“é¢˜åäºŒ åŸºç¡€DP]]></title>
    <url>%2F2017%2F12%2F20%2FACM%2Fkuangbin-12%2F</url>
    <content type="text"><![CDATA[kuangbin ä¸“é¢˜åäºŒ åŸºç¡€DP LIS dp[ i ]ä»£è¡¨å‰iä¸ªæ•°çš„æœ€é•¿å­åºåˆ—å¤§å° dp[ i ] =max { dp[ j ] + 1 } ( val[ j ] &lt; val[ i ] ) $ O ( n^2 ) $ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int dp[ N ], val[ N ]; int LIS ( int n ) &#123; int mx = 0; for ( int i = 0; i &lt; n; ++i ) &#123; dp[ i ] = 1; for ( int j = 0; j &lt; i; ++j ) &#123; if ( val[ j ] &lt; val[ i ] &amp;&amp; dp[ i ] &lt; dp[ j ] + 1 ) dp[ i ] = dp[ j ] + 1; &#125; if ( mx &lt; dp[ i ] ) mx = dp[ i ]; &#125; return mx; &#125; $ O ( nlgn ) $ http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ http://blog.csdn.net/shuangde800/article/details/7474903 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int val[ N ];//è¾“å…¥çš„å€¼ int len;//edæ•°ç»„çš„é•¿åº¦ï¼ˆLISé•¿åº¦ï¼‰ int ed[ N ];//æ¯ä¸ªé•¿åº¦çš„åºåˆ—çš„æœ«å°¾ //ä¸‹ç•Œï¼Œè¿”å›ž &gt;= æ‰€æŸ¥æ‰¾å¯¹è±¡çš„ç¬¬ä¸€ä¸ªä½ç½® int binary_search ( int i ) &#123; int left, right, mid; left = 0, right = len; while ( left &lt; right ) &#123; mid = left + ( right - left ) / 2; if ( ed[ mid ] &gt;= val[ i ] ) right = mid; else left = mid + 1; &#125; return left; &#125; void LIS ( int n ) &#123; ed[ 1 ] = val[ 1 ]; len = 1; for ( int i = 2; i &lt;= n; ++i ) &#123; //æ›´æ–°æœ€é•¿çš„æœ«å°¾ if ( val[ i ] &gt; ed[ len ] ) ed[ ++len ] = val[ i ]; //äº§ç”Ÿäº†æ–°çš„åºåˆ—ï¼Œæ”¹å˜æ—§çš„é•¿åº¦çš„æœ«å°¾ else &#123; // å¦‚æžœç”¨STLï¼š pos=lower_bound(ed,ed+len,val[i])-ed; int pos = binary_search ( i ); ed[ pos ] = val[ i ]; &#125; printf ( "%d\n", len ); &#125; &#125; LCS dp[ i ][ j ] ä»£è¡¨ä¸¤ä¸ªå­—ç¬¦ä¸²å‰i / j ä¸ªä¸‹çš„æœ€é•¿å¤§å° dp[ i ][ j ] = dp[ i - 1 ][ j - 1 ] + 1 ( val[ i ] == val[ j ] ) dp[ i ][ j ] = max ( dp[ i - 1 ][ j ], dp[ i ][ j - 1 ] ) ( != ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //CLRS 15.4 int len1, len2; char s1[ N ], s2[ N ]; int dp[ N ][ N ]; inline int max ( int a, int b ) &#123; return a &gt; b ? a : b; &#125; void LCS () &#123; for ( int i = 1; i &lt;= len1; i++ ) &#123; for ( int j = 1; j &lt;= len2; j++ ) &#123; if ( s1[ i ] == s2[ j ] ) dp[ i ][ j ] = dp[ i - 1 ][ j - 1 ] + 1; else dp[ i ][ j ] = max ( dp[ i - 1 ][ j ], dp[ i ][ j - 1 ] ); &#125; &#125; &#125; void Print ( int i, int j ) &#123; //å½“æœ€é•¿çš„å­åºåˆ—æœç´¢å®Œï¼Œä½†å…¶ä¸­ä¸€ä¸²ä»æœ‰å‰©ä½™æ—¶ï¼Œè¾“å‡º if ( i == 0 || j == 0 ) &#123; return; &#125; //æ‰¾åˆ°å…¬å…±å­—ç¬¦ if ( s1[ i ] == s2[ j ] ) &#123; Print ( i - 1, j - 1 ); printf ( "%c", s1[ i ] ); &#125; else if ( dp[ i - 1 ][ j ] &gt; dp[ i ][ j - 1 ] ) &#123; Print ( i - 1, j ); &#125; else &#123; Print ( i, j - 1 ); &#125; &#125; å®Œå…¨èƒŒåŒ… dp[ i ]ä»£è¡¨èƒŒåŒ…é‡içš„æ—¶å€™æœ€å¤§çš„ä»·å€¼ dp[ i ] = min ( dp[ i ], dp[ i - w[ j ] ] + v[ j ] ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int v[ N ], w[ N ]; // valueï¼Œweight int dp[ N ]; //nä¸ªç‰©å“ï¼Œæœ€å¤šè£…weiçš„ä¸œè¥¿ int knapsack ( int n, int wei ) &#123; memset ( dp, INF, sizeof ( dp ) ); dp[ 0 ] = 0; for ( int i = 1; i &lt;= wei; ++i ) &#123; for ( int j = 0; j &lt; n; ++j ) &#123; if ( i &gt;= w[ j ] ) dp[ i ] = min ( dp[ i ], dp[ i - w[ j ] ] + v[ j ] ); &#125; &#125; return dp[ wei ]; &#125; é¢˜ç›®åˆ—è¡¨ A - Max Sum Plus Plus HDU - 1024 nä¸ªæ•°ï¼Œè¦æ±‚åˆ†æˆmç»„ï¼Œä½¿mç»„çš„å’ŒåŠ èµ·æ¥å¾—åˆ°æœ€å¤§å€¼ã€‚ dp[i][j]è¡¨ç¤ºå‰jä¸ªæ•°åˆ†æˆiç»„çš„æœ€å¤§å€¼ã€‚ dp[i][j]=max(dp[i][j-1]+a[j],max(dp[i-1][k])+a[j]) B - Ignatius and the Princess IV HDU - 1029 ç»™n(å¥‡æ•°)ä¸ªæ•°ï¼Œå®šä¹‰ç‰¹æ®Šçš„æ•°ä¸ºåœ¨åºåˆ—ä¸­å‡ºçŽ°æ¬¡æ•°ä¸å°‘äºŽ(n+1)/2æ¬¡çš„æ•°ï¼Œæ‰¾å‡ºè¿™ä¸ªç‰¹æ®Šçš„æ•° ä¸€è¾¹è¾“å…¥ä¸€è¾¹è®°å½•ä¸ªæ•°å°±å¥½äº† C - Monkey and Banana HDU - 1069 ç»™å®šç®±å­ç§ç±»æ•°é‡nï¼ŒåŠå¯¹åº”é•¿å®½é«˜ï¼Œæ¯ä¸ªç®±å­æ•°é‡æ— é™ï¼Œæ±‚å…¶èƒ½å èµ·æ¥çš„æœ€å¤§é«˜åº¦æ˜¯å¤šå°‘(ä¸Šé¢ç®±å­çš„é•¿å®½ä¸¥æ ¼å°äºŽä¸‹é¢ç®±å­) æŒ‰ç…§é•¿æŽ’åºï¼Œåœ¨æ±‚å®½å…³äºŽé«˜çš„LIS D - Doing Homework HDU - 1074 æœ‰né—¨åŠŸè¯¾éœ€è¦å®Œæˆï¼Œæ¯ä¸€é—¨åŠŸè¯¾éƒ½æœ‰æ—¶é—´æœŸé™ä»¥åŠä½ å®Œæˆæ‰€éœ€è¦çš„æ—¶é—´ï¼Œå¦‚æžœå®Œæˆçš„æ—¶é—´è¶…å‡ºæ—¶é—´æœŸé™å¤šå°‘å•ä½ï¼Œå°±ä¼šè¢«å‡å¤šå°‘å­¦åˆ†ï¼Œé—®ä»¥æ€Žæ ·çš„åŠŸè¯¾å®Œæˆé¡ºåºï¼Œä¼šä½¿å‡æŽ‰çš„å­¦åˆ†æœ€å°‘ï¼Œæœ‰å¤šä¸ªè§£æ—¶ï¼Œè¾“å‡ºåŠŸè¯¾åæŽ’åˆ—æœ€å°çš„ä¸€ä¸ªã€‚ 15ä¸ªä½œä¸šçŠ¶æ€åŽ‹ç¼©æ¥åš æžšä¸¾æ¯ä¸€ä¸ªçŠ¶æ€ï¼Œæžšä¸¾æ¯ä¸ªçŠ¶æ€æ–°å¢žçš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œå†è®¡ç®—æœ€å°å¹¶è®°å½•å‰ä¸€ä¸ªçŠ¶æ€ E - Super Jumping! Jumping! Jumping! HDU - 1087 ä»Žèµ·ç‚¹åˆ°è¾¾ç»ˆç‚¹ï¼Œåªèƒ½å‰è¡Œä¸èƒ½åŽé€€ï¼Œä¸”ä¸‹ä¸€æ­¥å¿…é¡»æ¯”å‰é¢çš„ç‚¹çš„å€¼å¤§ï¼Œæ±‚æ‰€æœ‰èµ°çš„ç‚¹çš„å€¼æ€»å’Œæœ€å¤§æ˜¯å¤šå°‘ã€‚ dp[i] = max(dp[k] + a[j]); 1&lt;=k&lt;=i-1; æœ€å¤§é€’å¢žå­ä¸²å’Œã€‚ F - Piggy-Bank HDU - 1114 ç»™å‡ºå­˜é’±ç½æœ¬èº«çš„é‡é‡å’Œè£…é’±åŽçš„é‡é‡ï¼Œä»¥åŠå­˜é’±ç½ä¸­é’±çš„é¢å€¼å’Œé‡é‡ï¼Œæ±‚å­˜é’±ç½è£…æ»¡æ—¶ï¼Œé’±çš„æ€»å’Œæœ€å°æ˜¯å¤šå°‘ å®Œå…¨èƒŒåŒ…è§£é¢˜ï¼Œæ¯ç§é’±å¸éƒ½å¯ä»¥è£…æ— é™ä¸ªï¼Œæ³¨æ„åˆå§‹åŒ–çš„å€¼ dp[ i ] = min ( dp[ i ], dp[ i - w[ j ] ] + v[ j ] ); G - å…è´¹é¦…é¥¼ HDU - 1176 0â€”10çš„ç‚¹ï¼Œä¸åŒæ—¶é—´åœ¨æ¯ä¸ªç‚¹ä¸ŠæŽ‰ä¸‹æ¥ç‰©å“ï¼Œåªèƒ½åˆ°è¾¾å·¦å³ä¸¤è¾¹è·ç¦»ä¸º1å’Œæœ¬èº«æ‰€åœ¨çš„ä½ç½®ï¼Œæ±‚æœ€å¤§ç‰©å“æ•° dp[x][t] = max ( dp[x-1][t-1],dp[x][t-1],dp[x+1][t-1]) + v[x][t] H - Tickets HDU - 1260 å•å¼ æˆ–ä¸¤å¼ ä¸€èµ·ä¹°ï¼Œç»™å‡ºä¸€ä¸ªä¸€ä¸ªä¹°ç¥¨å’Œä¸¤ä¸ªä¸¤ä¸ªä¹°ç¥¨çš„æ—¶é—´ï¼Œæ±‚æœ€å°‘ dp[ i ] = min ( dp[ i - 1 ] + s[ i ], dp[ i - 2 ] + d[ i - 1 ] ); I - æœ€å°‘æ‹¦æˆªç³»ç»Ÿ HDU - 1257 æ±‚æœ‰å¤šå°‘ä¸ªé€’å‡åºåˆ— åè¿‡æ¥ï¼Œè½¬æ¢æˆæ±‚æ•´ä¸ªç³»åˆ—æœ‰å¤šå°‘ä¸ªLISï¼Œåˆ™æ˜¯æ‰€æ±‚çš„ç»„æ•° J - FatMouseâ€™s Speed HDU - 1160 ç»™nä¸ªè€é¼ çš„ä½“é‡å’Œé€Ÿåº¦ï¼Œæ±‚æ‰¾å‡ºä¸€ä¸ªæœ€é•¿çš„åºåˆ—ï¼Œæ­¤åºåˆ—ä½“é‡é€’å¢žé€Ÿåº¦é€’å‡ æŒ‰ä½“é‡é€’å¢žæŽ’åºï¼Œå†æ±‚æœ€é•¿é€’å¢ž(æ­¤é€’å¢žè¡¨ç¤ºä½“é‡é€’å¢žé€Ÿåº¦é€’å‡)å­åºåˆ—ã€‚ dp[i] = max(dp[j]+1) 0&lt;=j&lt;=i-1 K - Jury Compromise POJ - 1015 å¿…é¡»æ»¡è¶³è¾©æ–¹æ€»åˆ†Då’ŒæŽ§æ–¹æ€»åˆ†Pçš„å·®çš„ç»å¯¹å€¼|D-P|æœ€å°ã€‚å¦‚æžœæœ‰å¤šç§é€‰æ‹©æ–¹æ¡ˆçš„ |D-P| å€¼ç›¸åŒï¼Œé‚£ä¹ˆé€‰è¾©æŽ§åŒæ–¹æ€»åˆ†ä¹‹å’ŒD+Pæœ€å¤§çš„æ–¹æ¡ˆå³å¯ã€‚ dp(j, k)è¡¨ç¤ºï¼Œå–j ä¸ªå€™é€‰äººï¼Œä½¿å…¶è¾©æŽ§å·®ä¸ºk çš„æ‰€æœ‰æ–¹æ¡ˆä¸­ï¼Œè¾©æŽ§å’Œæœ€å¤§çš„é‚£ä¸ªæ–¹æ¡ˆçš„è¾©æŽ§å’Œã€‚ ç»¼ä¸Šï¼šdp[j][k]=dp[j-1][k-V[i]]+S[i] æ­£å‘è®¡ç®—ï¼Œè¾“å‡ºçš„æ—¶å€™å°±ç”¨æ­£å‘çš„è¾“å‡ºäº†,ä¸è¿‡æ¯æ¬¡éƒ½è¦æŸ¥æ‰¾ä¸‹ä¸€ä¸ªä½ç½®æ˜¯å¦åœ¨ä¹‹å‰ç”¨è¿‡äº† L - Common Subsequence POJ - 1458 LCS LCSæ¨¡æ¿ M - Help Jimmy POJ - 1661 è€é¼ åœ¨æ—¶åˆ»0ä»Žé«˜äºŽæ‰€æœ‰å¹³å°çš„æŸå¤„å¼€å§‹ä¸‹è½.å½“Jimmyè½åˆ°æŸä¸ªå¹³å°ä¸Šæ—¶ï¼Œæ¸¸æˆè€…é€‰æ‹©è®©å®ƒå‘å·¦è¿˜æ˜¯å‘å³è·‘.å½“Jimmyè·‘åˆ°å¹³å°çš„è¾¹ç¼˜æ—¶ï¼Œå¼€å§‹ç»§ç»­ä¸‹è½ã€‚Jimmyæ¯æ¬¡ä¸‹è½çš„é«˜åº¦ä¸èƒ½è¶…è¿‡MAX dp[i][0] = min(dp[k][0]+l[i]-l[k], dp[k][1]+r[i]-l[k]) + h[i]-h[k]; (å·¦å·¦å’Œå·¦å³å–æœ€å°) dp[i][1] = min(dp[k][0]+r[i]-l[k], dp[k][1]+r[i]-r[k]) + h[i]-h[k];(å³å·¦å’Œå³å³å–æœ€å°) N - Longest Ordered Subsequence POJ - 2533 LIS LISæ¨¡æ¿ O - Treats for the Cows POJ - 3186 nä¸ªæ•°åœ¨ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ä¸­ï¼Œæ¯æ¬¡ä»Žé˜Ÿé¦–æˆ–é˜Ÿå°¾å‡ºã€‚å‡ºçš„ç¬¬nä¸ªæ•°ä¹˜ä»¥nï¼Œæœ€åŽåŠ èµ·æ¥ï¼Œæ±‚æœ€å¤§å’Œã€‚ dp[i][j] ä»£è¡¨ä»Žiå–åˆ°jçš„æœ€å¤§æ€»æ•° dp[i][j] = max(dp[i+1][j]+a[i] * (n+i-j) , dp[i][j-1]+a[j] * (n+i-j)); P - FatMouse and Cheese HDU - 1078 ç»™å®šä¸€å¹…å›¾ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€å®šæƒå€¼ï¼ŒçŽ°åœ¨æœ‰ä¸€åªè€é¼ åœ¨èµ·å§‹ç‚¹ï¼ˆ0,0ï¼‰ï¼Œä»–èƒ½æ°´å¹³æˆ–è€…åž‚ç›´ç§»åŠ¨1~kæ ¼ä¹‹åŽï¼Œåœåœ¨æŸç‚¹å¹¶èŽ·å¾—æƒå€¼ï¼Œè€Œä¸”æ¯æ¬¡ç§»åŠ¨åŽæ‰€åœ¨çš„ç‚¹ï¼Œéƒ½è¦æ¯”åˆšç¦»å¼€çš„é‚£ä¸ªç‚¹çš„æƒå€¼æ›´å¤§ï¼Œæ±‚æœ€å¤šèƒ½èŽ·å¾—å¤šå°‘æƒå€¼ã€‚ DP / Memoized dp[ x ][ y ] = dp[ xx ][ yy ] + val[ x ][ y ] Q - Phalanx HDU - 2859 ç»™äº†ä¸€ä¸ªå­—ç¬¦ä¸²çŸ©é˜µï¼Œæ±‚ä»¥æ¬¡å¯¹è§’çº¿æ–¹å‘å¯¹ç§°çš„æœ€å¤§å¯¹ç§°çŸ©é˜µã€‚ æ¯æ¬¡åªéœ€æ±‚æœ€å¤–é¢ä¸€å±‚å¯¹ç§°ä¸ªæ•°sumï¼Œå†å’Œå³ä¸Šè§’å¯¹ç§°çŸ©é˜µå¤§å°åŠ ä¸€å–æœ€å°å°±è¡Œï¼Œå°±æ±‚å‡ºå½“å‰å°çŸ©é˜µçš„æœ€å¤§å¯¹ç§°çŸ©é˜µã€‚æœ€åŽå–ä¸ªæ‰€æœ‰å¯¹ç§°çŸ©é˜µå¤§å°çš„æœ€å¤§å€¼å°±è¡Œã€‚ dp[i][j] = min(sum,dp[i-1][j+1]+1); R - Milking Time POJ - 3616 å¥¶ç‰›Bessieåœ¨0~Næ—¶é—´æ®µäº§å¥¶ã€‚å†œå¤«çº¦ç¿°æœ‰Mä¸ªæ—¶é—´æ®µå¯ä»¥æŒ¤å¥¶ï¼Œæ—¶é—´æ®µf,tå†…Bessieèƒ½æŒ¤åˆ°çš„ç‰›å¥¶é‡eã€‚å¥¶ç‰›äº§å¥¶åŽéœ€è¦ä¼‘æ¯Rå°æ—¶æ‰èƒ½ç»§ç»­ä¸‹ä¸€æ¬¡äº§å¥¶ï¼Œæ±‚Bessieæœ€å¤§çš„æŒ¤å¥¶é‡ã€‚ dp[ i ] = max ( dp[ j ] + node[ i ].val, dp[ i ] ) ( node[ j ].ed &lt;= node[ i ].st ) S - Making the Grade POJ - 3666 å†œå¤«çº¦ç¿°æƒ³ä¿®ä¸€æ¡å°½é‡å¹³ç¼“çš„è·¯ï¼Œè·¯çš„æ¯ä¸€æ®µæµ·æ‹”æ˜¯A_iï¼Œä¿®ç†åŽæ˜¯B_iï¼ŒèŠ±è´¹|A_i â€“ B_i|ï¼Œæ±‚æœ€å°èŠ±è´¹ã€‚ dp[i][j] = min(dp[i â€“ 1][k]) + |A[i] â€“ B[j]| ç¦»æ•£åŒ–]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GSLA ch-6] Eigenvalues and Eigenvectors]]></title>
    <url>%2F2017%2F12%2F14%2FLA%2FEigenvalues%20and%20Eigenvectors%2F</url>
    <content type="text"><![CDATA[Eigenvalues and Eigenvectors 6.1 Introduction certain vectors x are in the same direction as Ax basic equation: â€‹ $ Ax = \lambda x $ how to compute: let $ det(A-\lambda x)= 0 $ ,find the roots == find eigenvalues, find eigenvectors in Null space $ A^nx = \lambda^n x $ span eigenspace Projection: $ \lambda = 1 $ or 0 Reflection: $ \lambda = 1 $ or -1 Rotation: complex eigenvalues only product of eigenvalues == determinant == product of pivots sum of eigenvalues == sum of diagonal entries ( not pivots ) == trace 6.2 Diagonalizing eigenvectors in columns of S, eigenvalues in diagonal of Î› $ Î› = S^{-1}AS $ $ A = SÎ›S^{-1} $ Independent x from different Î»: $ c_1 Î»_1 x_1 + c_2 Î»_2 x_2 = 0 $ $ c_1 Î»_2 x_2 + c_2 Î»_2 x_2 = 0 $ subtract $ (Î»_1 - Î»_2)c_1x_1 = 0 $ diagonalizability: enough eigenvectors (maybe same Î») so that S is invertible uk=Aku0=SÎ›kSâˆ’1u0u_k = A^k u_0 = S \Lambda^k S^{-1}u_0uâ€‹kâ€‹â€‹=Aâ€‹kâ€‹â€‹uâ€‹0â€‹â€‹=SÎ›â€‹kâ€‹â€‹Sâ€‹âˆ’1â€‹â€‹uâ€‹0â€‹â€‹ $ u_0 = c_1x_1 + c_2x_2 + â€¦ +c_nx_n $ eigenvector basis multiply Î»ik\lambda_i ^ kÎ»â€‹iâ€‹kâ€‹â€‹ add up A,B share same eigenvector matrix S if and only if AB = BA ?Heisenberg uncertainty principle position matrix P, momentum matrix Q, $ QP-PQ = I $ knew P still could not know Q $ |Px||Qx| \ge \frac{1}{2}|x|^2 $ 6.3 Applications to Differential Equations 6.4 Symmetric Matrices real eigenvalues orthonormal eigenvectors Spectral Theorem (principle of axis theorem) $ A = Q\Lambda Q^T $ Normal Matrices $ \bar A^TA = A \bar A^T $ symmetric, skewed-symmetric, orthogonal A has n orthonormal vectors ($ A = Q\Lambda \bar Q ^T $) if and only if A is normal Real Eigenvalues proof: $ Ax = \lambda x $ $ \bar x ^TA = \bar x ^T \bar\lambda $ ( $ A = A^T $ )( conjugate and transpose ) $ \bar x^T A x = \bar x^T \lambda x $ $ \bar x ^ T A x = \bar x ^ T \bar\lambda x $ left side the same therefor $ \lambda == \bar \lambda $ Orthonormal proof: no eigenvalues repeated Allow repeated eigenvalues ( ? Schurâ€™s Theorem ) sum of rank one projection matrices $ A = \lambda_1x_1x_1^T + \lambda_2x_2x_2^T+â€¦ $ $ = \lambda_1P_1 +\lambda_2P2+â€¦ $ number of positive pivots == number of positive eigenvalues $ A = LDL^T $ 6.5 Positive Definite Matrices All Î» &gt; 0 quick way to test All pivots positive n eigenvalues positive $ x^TAx $ is positive except x = 0 $ A == R^TR $ (symmetric) and R has independent columns ($ x^T R^TRX &gt;= 0 $) n upper left determinants R can be chosen: rectangular / $ (L\sqrt D)^T $ / $ Q \sqrt\Lambda Q^T $ $x^TAx $ (2*2) = $ ax^2 + 2bxy + cy^2 &gt; 0 $ ( ellipse $ z = x2/a2 + y2/b2 $ ) Application tilted ellipse $ x^TAx $ lined - up ellipse $ X^T\Lambda X = 1 $ rotation matrix Q axes: eigenvectors half-length: $ 1/\sqrt\lambda $ 6.6 Similar Matrices DEF: A similar to B (A family) $ B = M^{-1}AM $ Property: A and B have same eigenvalues x a eigenvector of A and $ M^{-1}x $ eigenvector of B Jordan Form triple eigenvalues while one eigenvector J with Î» in the diagonal and 1 above similar to every matrices with repeated eigenvalues Î» and one eigenvector Î» repeated only once than J == Î› Jordan Block make A as simple as possible while preserving essential properties 6.7 Singular Value Decomposition SUMMARY $ A = U \Sigma V^T $ $ \Sigma^2 = \Lambda $ (of $ A^TA $ and $ AA^T $ ) $ U = Q $ (of $ AA^T $ in $ R^m $) $ V = Q $ (of $ A^TA $ in $ R^n $) orthonormal basis of row space {$ v_1, v_2, â€¦ v_r $} orthonormal basis of null space{ $ v_{r+1}, v_{r+2},â€¦v_n $} orthonormal basis of column space{ $ u_1, u_2,â€¦u_r $} orthonormal basis of left null space { $ u_{r+1}, u_{r+2}, â€¦ u_m $} Rotation â€“ Stretch â€“ Rotation $ Av_1 = \sigma_1u_1 $ â€¦ so $ AV = U\Sigma $ (m * n) * (n * n) = (m * m)* (m * n) $ V $ and $ U $ are orthogonal matrices $ \Sigma $ = ( old r*r $ \Sigma $ ) + (m-r zero rows) + ( n-r zero columns ) therefore â€¦ when A positive definite symmetric $ A = U \Sigma V^T = Q\Lambda Q^{T} $ 7.3 Diagonalization and the Pseudoinverse change bases $ \Lambda { w â€“ w } = S^{-1}{std â€“ w} A_{std} S_{ w â€“ std } $ $ \Sigma { v â€“ u } = U^{-1}{std â€“ u} A{std}V{v â€“ std} $ Polar Decomposition orthogonal and semidefinite rotation and stretching $ A = U\Sigma V^T = ( UV^T ) (V \Sigma V^T) = QH $ Pseudoinverse $ A^+ = V\Sigma^+ U^T $]]></content>
      <tags>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbinä¸“é¢˜å›› æœ€çŸ­è·¯]]></title>
    <url>%2F2017%2F12%2F10%2FACM%2Fkuangbin-4%2F</url>
    <content type="text"><![CDATA[kuangbinä¸“é¢˜å›› æœ€çŸ­è·¯ ACMå›¾è®ºå­˜å›¾æ–¹å¼ http://jzqt.github.io/2015/07/21/ACMå›¾è®ºä¹‹å­˜å›¾æ–¹å¼/ å•æºæœ€çŸ­è·¯ Dijkstra â€‹ $ O(V^2 + E) $ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int edg[ N ][ N ]; // weight of each edge int dis[ N ]; // distance of each node from source bool vis[ N ]; // SET S represent for nodes already visited // CLRS 24.3 // s:start point, n: total number of nodes void dijkstra ( int s, int n ) &#123; // INITIALIZE-SINGLE-SOURCE memset ( vis, false, sizeof ( vis ) ); vis[ s ] = true; for ( int i = 1; i &lt;= n; ++i ) dis[ i ] = edg[ s ][ i ]; dis[ s ] = 0; // Extract Min // u for the node, mi for dis[ u ] for ( int i = 1; i &lt;= n - 1; ++i ) &#123; int u = -1, mi = INF; for ( int j = 1; j &lt;= n; ++j ) if ( !vis[ j ] &amp;&amp; dis[ j ] &lt; mi ) mi = dis[ u = j ]; vis[ u ] = true; // Relax edges adjacent to u for ( int j = 1; j &lt;= n; ++j ) if ( !vis[ j ] ) dis[ j ] = min ( dis[ j ], dis[ u ] + edg[ u ][ j ] ); &#125; &#125; Dijkstra + STL priority_queue â€‹ $ O((V+E)lgV) $ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int head[ N ]; //é“¾å¼å‰å‘æ˜Ÿå»ºå›¾ int dis[ N ]; // distance of each node from source bool vis[ N ]; // SET S represent for nodes already visited struct Node &#123; int u, d; // id, dis bool operator&lt; ( const Node &amp;rhs ) const &#123; return d &gt; rhs.d; &#125; &#125;; struct Edge &#123; int u, v, w, nex; &#125; edg[ N ]; // CLRS 24.3 // s:start point void dijkstra ( int s ) &#123; priority_queue&lt;Node&gt; Q; dis[ s ] = 0; Q.push ( ( Node )&#123;s, dis[ s ]&#125; ); while ( !Q.empty () ) &#123; // u = Extract_Min( Q ) Node x = Q.top (); Q.pop (); int u = x.u; if ( vis[ u ] ) continue; vis[ u ] = true; // for each vertex v in G.adj[ u ] for ( int i = head[ u ]; i != -1; i = edg[ i ].nex ) &#123; int v = edg[ i ].v; int w = edg[ i ].w; // relax if ( dis[ v ] &gt; dis[ u ] + w ) &#123; dis[ v ] = dis[ u ] + w; Q.push ( ( Node )&#123;v, dis[ v ]&#125; ); &#125; &#125; &#125; &#125; SPFA (Shortest Path Faster Algorithm) â€‹ $ O(kE) $ ( k &lt; 2 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 int dis[ N ]; // distance of each node from source bool vis[ N ]; // SET S represent for nodes already visited int cnt[ N ]; //å…¥åˆ—æ¬¡æ•°è¶…è¿‡nï¼Œæœ‰è´ŸçŽ¯ int head[ N ]; //é“¾å¼å‰å‘æ˜Ÿ struct edg &#123; int u, v, w, nex; &#125; edg[ N ]; bool SPFA ( int s, int n ) &#123; // INIT memset ( vis, false, sizeof ( vis ) ); vis[ s ] = true; for ( int i = 1; i &lt;= n; ++i ) dis[ i ] = INF; dis[ s ] = 0; memset ( cnt, 0, sizeof ( cnt ) ); cnt[ s ] = 1; // BFSæ–¹å¼çš„spfa queue&lt;int&gt; Q; Q.push ( s ); while ( !Q.empty () ) &#123; int u = Q.front (); Q.pop (); vis[ u ] = false; // å‡ºé˜Ÿè¦å–æ¶ˆæ ‡è®° for ( int i = head[ u ]; i != -1; i = edg[ i ].nex ) &#123; int v = edg[ i ].v; // Relaxæ‰€æœ‰å‡ºè¾¹ if ( dis[ v ] &gt; dis[ u ] + edg[ i ].w ) &#123; dis[ v ] = dis[ u ] + edg[ i ].w; //æ²¡å…¥é˜Ÿçš„æ ‡è®°å¹¶å…¥é˜Ÿ if ( !vis[ v ] ) &#123; vis[ v ] = true; Q.push ( v ); // åˆ¤æ–­è´ŸçŽ¯ if ( ++cnt[ v ] &gt; n ) return false; &#125; &#125; &#125; &#125; return true; &#125; è´´ä¸€ä¸ªdfsçš„ï¼Œè‡ªå·±æ²¡å†™è¿‡ï¼Œæ„Ÿè§‰dijkstra+heapæœ€å¥½ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int spfa_dfs ( int u ) &#123; vis[ u ] = true; for ( int i = head[ u ]; i != -1; i = edg[ i ].nex ) &#123; int v = edg[ i ].v, w = edg[ i ].w; if ( dis[ u ] + w &lt; dis[ v ] ) &#123; dis[ v ] = dis[ u ] + w; if ( !vis[ v ] ) &#123; if ( spfa_dfs ( v ) ) return 1; &#125; else return 1; &#125; &#125; vis[ u ] = false; return 0; &#125; Bellman-Ford â€‹ $ O(VE) $ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int dis[ N ]; // distance of each node from source bool vis[ N ]; // SET S represent for nodes already visited struct edg &#123; int u, v, w; &#125; edg[ N ]; //CLRS 24.1 //å¯¹æ¯ä¸ªç‚¹ï¼Œrelaxæ‰€æœ‰çš„è¾¹ bool Bellman_Ford ( int n, int e, int s, double num ) &#123; // Initialize Single Sorce( G,s ) for ( int i = 1; i &lt;= n; ++i ) dis[ i ] = 0; dis[ s ] = num; // for i = 1 to |G.V|-1 for ( int i = 0; i &lt; n - 1; ++i ) &#123; // for each edg ( u,v ) in G.E for ( int j = 0; j &lt; e; ++j ) &#123; int u = edg[ j ].u; int v = edg[ j ].v; // Relax if ( dis[ v ] &gt; dis[ u ] + edg[ j ].w ) &#123; dis[ v ] = dis[ u ] + edg[ u ].w; &#125; &#125; &#125; // å­˜åœ¨è´ŸçŽ¯ for ( int i = 0; i &lt; e; ++i ) if ( dis[ edg[ i ].v ] &gt; ( dis[ edg[ i ].u ] - edg[ i ].w ) ) return false; return true; &#125; é€‚ç”¨åœºæ™¯ å¦‚æžœæ˜¯ç¨ å¯†å›¾ï¼ŒDijkstra+heapæ¯”SPFAå¿«ã€‚ç¨€ç–å›¾åˆ™SPFAæ›´å¿«ã€‚å†å°±æ˜¯SPFAå¯ä»¥åˆ¤æ–­è´ŸçŽ¯ å¯¹äºŽæžç«¯çš„é“¾çŠ¶å›¾ï¼ŒSPFAæ— ç–‘æ˜¯æœ€åˆé€‚çš„äº†ã€‚æ¯ä¸ªç»“åªè¿›é˜Ÿä¸€æ¬¡ï¼Œæ ‡å‡†çš„O(E)ã€‚ æœ´ç´ çš„dijkstraå¯¹äºŽè¿™æ ·çš„å›¾å°±åŠ›ä¸ä»Žå¿ƒäº†ï¼šæ¯æ¬¡å¾ªçŽ¯éƒ½è¿‡ä¸€éç»“ç‚¹ï¼Œåœ¨æ¾å¼›ï¼Œç„¶åŽå‘çŽ°æ¯æ¬¡O(V)çš„æ—¶é—´åªæ¾å¼›äº†ä¸€ä¸ªç‚¹ã€‚ â€‹ å¤šæºæœ€çŸ­è·¯ Floyd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // CLRS 25.2 All-Pairs-Shortest-Path void Floyd () &#123; // Dp // è¡¨ç¤ºæ‰€æœ‰ç‚¹åªç»è¿‡é›†åˆ&#123; 1..k &#125;å†…çš„ç‚¹æ—¶çš„æœ€çŸ­è·¯å¾„ // åªç»è¿‡1çš„æ—¶å€™relaxä¸€æ¬¡ï¼Œåœ¨æ·»åŠ ä¸Šç»è¿‡2åŽçš„relaxï¼Œæœ€åŽä¸€ç›´åˆ°n for ( int k = 1; k &lt;= n; ++k ) &#123; //é€‰å–æ¯ä¸€ä¸ªèµ·ç‚¹ for ( int i = 1; i &lt;= n; ++i ) //é€‰å–æ¯ä¸€ä¸ªç»ˆç‚¹ for ( int j = 1; j &lt;= n; ++j ) // d(ij)^k = min &#123; d(ik)^(k-1) + d(kj)^(k-1) &#125; dis[ i ][ j ] = dis[ i ][ j ] || ( dis[ i ][ k ] &amp;&amp; dis[ k ][ j ] ); &#125; &#125; é¢˜ç›®åˆ—è¡¨ A - Til the Cows Come Home POJ-2387 ä¸€ä¸ªå†œåœºæœ‰n (1000)ä¸ªç‚¹ï¼Œæœ‰t (2000)æ¡é“è·¯è¿žæŽ¥, ä»Žnåˆ°1æœ€çŸ­ dijkstra æ¨¡æ¿ B - Frogger POJ-2253 æ— å‘å›¾ä¸€æ¡1~2çš„è·¯å¾„ä½¿å¾—è¯¥è·¯å¾„ä¸Šçš„æœ€å¤§è¾¹æƒæœ€å°. (max Route weight is the minimum among all routes) dijkstraå˜å½¢ double minimax = max ( mi, v[ j ][ u ] ); C - Heavy Transportation POJ - 1797 â€‹ æœ‰nä¸ªåŸŽå¸‚ï¼Œnä¸ªåŸŽå¸‚ä¹‹é—´æœ‰mæ¡å…¬è·¯æˆ–æ¡¥æ¢ï¼Œæ¯ä¸ªå…¬è·¯æˆ–æ¡¥éƒ½æœ‰ä¸€ä¸ªæœ€å¤§è½½é‡é‡ï¼Œé—®ä»ŽåŸŽå¸‚1åˆ°åŸŽå¸‚næ‰€èƒ½è¿é€åˆ°è´§ç‰©åˆ°æœ€å¤§é‡é‡æ˜¯å¤šå°‘ ( min Route weight is the maximum among all routes ) dijkstraå˜å½¢ int maxmini = min ( mi, v[ j ][ u ] ); D - Silver Cow Party POJ - 3268 nä¸ªå†œåœºï¼Œmæ¡å•å‘è·¯ï¼Œnä¸ªç‰›åˆ†åˆ«åœ¨nä¸ªå†œåœºï¼Œç¬¬xå†œåœºä¸ºç»ˆç‚¹ï¼Œé—®æ¯ä¸ªç‰›ä»Žæ‰€åœ¨å†œåœºå‰å¾€xå†œåœºçš„å¾€è¿”è·¯ç¨‹æœ€å°å€¼æ˜¯å¤šå°‘ï¼Œæ±‚å‡ºnä¸ªç‰›ä¸­æœ€çŸ­è·¯ä¸Šå¾€è¿”è·¯ç¨‹çš„æœ€å¤§çš„é‚£ä¸ª ä»Žnä¸ªç‚¹åˆ°1å†ä»Ž1å›žåˆ°nä¸ªç‚¹ï¼Œé€šè¿‡è°ƒè½¬è¾¹çš„æ–¹å‘ä¸¤æ¬¡dijkstra E - Currency Exchange POJ - 1860 æœ‰nç§è´§å¸ï¼Œä½ å«æœ‰numé¢é¢çš„å…¶ä¸­ä¸€ç§è´§å¸ã€‚æ±‚æœ‰æ²¡æœ‰å¯èƒ½ï¼Œåœ¨å¤šæ¬¡å…‘æ¢åŽä½ æ‰‹ä¸­çš„è´§å¸å¤§äºŽnumã€‚ æ±‚æœ€å¤§è·¯å¾„ï¼Œåå‘ç”¨Bellman-Ford F - Wormholes POJ - 3259 å†œåœºä¹‹é—´æœ‰å¾ˆå¤šæ¡è·¯ï¼Œä»¥åŠå•å‘çš„è™«æ´žï¼Œæ¯æ¡è·¯èµ°å®Œä¼šèŠ±è´¹ä¸€å®šçš„æ—¶é—´ï¼Œè€Œè™«æ´žå¯ä»¥å›žåˆ°ä¹‹å‰çš„æ—¶é—´ï¼Œé—®å†œåœºä¸»æ˜¯å¦èƒ½å›žåˆ°è‡ªå·±å‡ºå‘æ—¶é—´å‰çš„å‡ºå‘ç‚¹ SPFAåˆ¤æ–­è´ŸçŽ¯ G - MPI Maelstrom POJ - 1502 ä»Žç¬¬ä¸€ä¸ªç‚¹å‡ºå‘ï¼Œæ±‚åˆ°å…¶ä»–ç‚¹æœ€çŸ­è·¯çš„æœ€å¤§å€¼ dijkstra æ³¨æ„ä¸‹ä¸‰è§’çŸ©é˜µé‚»æŽ¥è¡¨çš„å»ºå›¾ H - Cow Contest POJ - 3660 nä¸ªç‰›è¿›è¡Œæ¯”èµ›ï¼ŒçŽ°å·²çŸ¥mä¸ªå…³ç³»ï¼Œ ç‰›uå¯ä»¥èƒœè¿‡ç‰›vã€‚é—®æœ€åŽå¯ä»¥ç¡®å®šæŽ’åä½æ•°çš„æœ‰å‡ ä¸ªç‰›. Floydåˆ¤æ–­ä¸¤ä¸¤ç‰›ä¹‹é—´çš„å…³ç³»ã€‚å¦‚æžœä¸€ä¸ªç‰›å¯ä»¥èƒœè¿‡aä¸ªç‰›ï¼Œbä¸ªç‰›å¯ä»¥èƒœè¿‡å®ƒï¼Œé‚£ä¹ˆå¦‚æžœaï¼‹bï¼nï¼1ï¼Œä»–çš„æŽ’åå°±å¯ä»¥ç¡®å®š I - Arbitrage POJ - 2240 ç»™å®šå¤šç§è´§å¸ä¹‹é—´çš„å…‘æ¢å…³ç³»ï¼Œé—®æ˜¯å¦å¯ä»¥å¥—åˆ© Bellman-Fordåˆ¤æ–­æ­£çŽ¯ï¼ˆè¦è¿”å›žè‡ªå·±æ‰€ä»¥æ¾å¼›næ¬¡) floydåˆ¤æ–­å›žæ¥åŽæ˜¯å¦&gt;1 J - Invitation Cards POJ - 1511 æ±‚æºç‚¹åˆ°å„ç‚¹çš„å¾€è¿”æœ€çŸ­è·¯ä¹‹å’Œ é‚»æŽ¥è¡¨é€†ç½®ï¼ˆå»ºäº†ä¸¤ä¸ªé‚»æŽ¥è¡¨ï¼‰ æ•°æ®å¤šéœ€è¦ä¼˜åŒ–SPFA/dijkstra+heap K - Candies POJ - 3159 ç»™nä¸ªäººåˆ†ç³–æžœï¼Œmç»„æ•°æ®aï¼Œbï¼Œcï¼›æ„æ€æ˜¯aæ¯”bå°‘çš„ç³–æžœä¸ªæ•°ç»å¯¹ä¸è¶…è¿‡cä¸ªï¼Œä¹Ÿå°±æ˜¯d(b)-d(a) &lt; cï¼Œæ±‚1æ¯”nå°‘çš„ç³–æžœæ•°çš„æœ€å¤§å€¼ã€‚ å·®åˆ†çº¦æŸï¼Œå’Œæœ€çŸ­è·¯çš„æ¾å¼›ä¸€æ · æ•°æ®å¤šï¼Œdijkstra+heap L - Subway POJ - 2502 å°æ˜Žæ­¥è¡Œçš„é€Ÿåº¦æ˜¯10km/hï¼Œåœ°é“é€Ÿåº¦æ˜¯40km/hï¼Œç»™å®šå®¶å’Œå­¦æ ¡çš„åæ ‡ï¼Œå†ç»™å®šå¤šæ¡åœ°é“çº¿è·¯ç«™ç‚¹çš„åæ ‡ï¼Œé—®å°æ˜Žä»Žå®¶åˆ°å­¦æ ¡æ‰€éœ€çš„æœ€çŸ­æ—¶é—´ dijkstraï¼Œå»ºå›¾è¿žæŽ¥æ‰€æœ‰çš„ç‚¹å¹¶èµ‹å€¼æ—¶é—´ M - æ˜‚è´µçš„è˜ç¤¼ POJ - 1062 æ¯ä¸ªäººå¯èƒ½æœ‰ç›´æŽ¥è´­ä¹°æˆ–è€…äº¤æ¢ç‰©å“æ¢å–æŠ˜æ‰£è¿™ä¸¤ç§æ–¹å¼äº¤æ˜“ï¼ˆäº¤æ¢ç‰©å“è¦ä»Žåˆ«äººæ‰‹é‡Œä¹°ï¼‰ ç­‰çº§å·®ä¹‹é—´è¶…è¿‡mçš„ä¸èƒ½äº¤æ˜“ æ±‚ç”¨æœ€å°‘çš„é’±ä¹°åˆ°éžæ´²å¤§é…‹é•¿çš„æ‰¿è¯º ç­‰çº§é™åˆ¶é‡‡ç”¨æžšä¸¾çš„æ–¹æ³•ï¼Œåˆ†åˆ«ä»Žlv[ 1 ] - m ~~ lv[ 1 ] + mï¼Œæ¯æ¬¡æžšä¸¾çš„åŒºé—´é•¿åº¦ä¸ºm,ä¸€å…±mæ¬¡æœ€çŸ­è·¯æœç´¢ N - Tram POJ - 1847 ç”µåŠ¨å·´å£«åœ¨æ¯ä¸ªåå­—è·¯å£æœ‰ä¸€ä¸ªé»˜è®¤æ–¹å‘ï¼Œèµ°å‘åˆ«çš„æ–¹å‘éœ€è¦æ”¹åŠ¨æ‰³æ‰‹ã€‚ dijkstra æ¯ä¸ªè¾¹åˆå§‹åŒ–ä¸ºINF,è¦åˆ‡æ¢çš„è·¯ = 1,ä¸ç”¨åˆ‡æ¢ = 0 O - Extended Traffic LightOJ - 1074 ç»™å®šæ¯æ¡è¡—çš„æ‹¥æŒ¤åº¦p(x)ï¼Œè¡—aåˆ°è¡—bçš„æ—¶é—´å°±æ˜¯(p(b)-p(a))**3ï¼Œæ±‚ç¬¬ä¸€ä¸ªç‚¹åˆ°ç¬¬kä¸ªç‚¹çš„æœ€çŸ­è·¯ SPFAåˆ¤æ–­è´ŸçŽ¯ dfsè®°å½•è´ŸçŽ¯é‡Œçš„ç‚¹ P - The Shortest Path in Nya Graph HDU - 4725 å…±nä¸ªç‚¹ï¼Œnå±‚(æ¯ä¸ªç‚¹å•ç‹¬ä¸€å±‚)ï¼Œç›¸é‚»çš„ä¸¤å±‚ä¹‹é—´æƒå€¼ä¸ºw è¿˜æœ‰mæ¡é¢å¤–çš„è¾¹ï¼Œæƒå€¼ä¸ºvï¼Œæ±‚1åˆ°nçš„æœ€çŸ­è·¯ å»ºå›¾ ï¼ï¼ç»™æ¯ä¸ªç‚¹ä¸¤ä¸ªè¾…åŠ©ç‚¹ï¼Œä¸€ä¸ªåšå‡ºåº¦ï¼Œä¸€ä¸ªåšå…¥åº¦ Q - Marriage Match IV HDU - 3416 ç½‘ç»œæµï¼Œä¸ä¼šqwq R - 0 or 1 HDU - 4370 X12+X13+â€¦X1n=1,X1n+X2n+â€¦Xn-1n=1,å…¶ä½™è¡Œåˆ—å’Œç›¸åŒï¼Œæ±‚Î£Cij*Xij ç¥žä¸€æ ·çš„å»ºå›¾ï¼ï¼èŠ‚ç‚¹1çš„å‡ºåº¦ä¸º1.èŠ‚ç‚¹nçš„å…¥åº¦ä¸º1.èŠ‚ç‚¹2-n-1çš„å…¥åº¦å’Œå‡ºåº¦ç›¸ç­‰. é—®é¢˜å°±ç›¸å½“äºŽæ±‚ä¸€æ¡æœ€çŸ­è·¯ï¼Œä»ŽèŠ‚ç‚¹1å‡ºå‘ï¼Œåˆ°èŠ‚ç‚¹N. åŒæ—¶èŠ‚ç‚¹1çš„ä¸€ä¸ªæœ€å°çŽ¯+èŠ‚ç‚¹nçš„ä¸€ä¸ªæœ€å°çŽ¯ä¹Ÿæ˜¯å¯è¡Œè§£ï¼Œä¸¤è€…å–æœ€å° S - Layout POJ - 3169 ä¸¤ç‚¹é—´å¯èƒ½&lt;= x æˆ–è€…&gt;=xï¼Œæ±‚1â€“&gt;næœ€å¤§ å·®åˆ†çº¦æŸï¼Œå’Œæœ€çŸ­è·¯ä¸€æ ·ï¼ŒSPFAåˆ¤æ–­è´ŸçŽ¯åˆ™ä»£è¡¨ä¸å­˜åœ¨å¯è¡Œè§£]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1 $ hexo new "My New Post" More info: Writing Run server 1 $ hexo server More info: Server Generate static files 1 $ hexo generate More info: Generating Deploy to remote sites 1 $ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
